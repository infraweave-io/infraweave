version: 0.2

phases:
  install:
    commands:
      - apt-get update && apt-get install -y wget unzip jq bc
      - wget https://releases.hashicorp.com/terraform/1.5.7/terraform_1.5.7_linux_amd64.zip
      - unzip terraform_1.5.7_linux_amd64.zip
      - mv terraform /usr/local/bin/
  pre_build:
    commands:
      # - terraform fmt -check
      - export LOG_QUEUE_NAME=logs-${DEPLOYMENT_ID}
      # - aws sqs create-queue --queue-name $LOG_QUEUE_NAME # Due to delay in queue creation, we will create the queue in the apiInfra lambda
      - echo "Started work..." >> terraform_init_output.txt
      - aws sqs send-message --queue-url "https://sqs.${REGION}.amazonaws.com/${ACCOUNT_ID}/$LOG_QUEUE_NAME" --message-body "$(cat terraform_init_output.txt)" &
      - >
        while sleep 1; do
          if pgrep terraform > /dev/null; then
            aws sqs send-message --queue-url "https://sqs.${REGION}.amazonaws.com/${ACCOUNT_ID}/$LOG_QUEUE_NAME" --message-body "$(cat terraform_init_output.txt)" &
          else
            break
          fi
        done &
      - terraform init -no-color -backend-config="bucket=${TF_BUCKET}" -backend-config="key=${ENVIRONMENT}/${REGION}/${DEPLOYMENT_ID}/terraform.tfstate" -backend-config="region=${REGION}" -backend-config="dynamodb_table=${TF_DYNAMODB_TABLE}" | tee terraform_init_output.txt
      - ret=$?
      - echo "\n\n\n\nInitiated with return code $ret" >> terraform_init_output.txt
      - terraform validate
      - aws sqs send-message --queue-url https://sqs.${REGION}.amazonaws.com/${ACCOUNT_ID}/$LOG_QUEUE_NAME --message-body "$(cat terraform_init_output.txt)"
  build:
    commands:
      - export LOG_QUEUE_NAME=logs-${DEPLOYMENT_ID}
      - export STATUS="started"
      - epoch_seconds=$(date +%s) # Seconds since epoch
      - nanoseconds=$(date +%N) # Nanoseconds since last second
      - epoch_milliseconds=$(echo "$epoch_seconds * 1000 + $nanoseconds / 1000000" | bc) # Convert nanoseconds to milliseconds and concatenate
      - >
        echo ${SIGNAL} | jq --arg status "$STATUS" --arg epoch "$epoch_milliseconds" --arg ts "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" ". + {status: \$status, timestamp: \$ts, epoch: (\$epoch | tonumber), id: (.deployment_id + \"-\" + .module + \"-\" + .name + \"-\" + .event + \"-\" + \$epoch + \"-\" + \$status)}" > signal_ts_id.json
      - >
        jq 'with_entries(if .value | type == "string" then .value |= {"S": .} elif .value | type == "number" then .value |= {"N": (tostring)} elif .value | type == "object" then .value |= {"M": (with_entries(if .value | type == "string" then .value |= {"S": .} else . end))} else . end)' signal_ts_id.json > signal_dynamodb.json
      - aws dynamodb put-item --table-name ${DYNAMODB_EVENT_TABLE} --item file://signal_dynamodb.json
      - echo "Started terraform ${EVENT}..." >> terraform_output.txt
      - aws sqs send-message --queue-url "https://sqs.${REGION}.amazonaws.com/${ACCOUNT_ID}/$LOG_QUEUE_NAME" --message-body "$(cat terraform_output.txt)" &
      - >
        while sleep 1; do
          if pgrep terraform > /dev/null; then
            aws sqs send-message --queue-url "https://sqs.${REGION}.amazonaws.com/${ACCOUNT_ID}/$LOG_QUEUE_NAME" --message-body "$(cat terraform_output.txt)" &
          else
            break
          fi
        done &
      - terraform ${EVENT} -auto-approve -no-color > terraform_output.txt 2>&1 && export ret=0 || export ret=$?
      - echo "\n\n\n\nFinished with return code $ret" >> terraform_output.txt
      - cat terraform_output.txt
      - export INPUT_VARIABLES="$(printenv | grep '^TF_VAR_' | sed 's/^TF_VAR_//;s/=/":"/;s/^/{"/;s/$/\"}/' | jq -s 'add')"
      - aws sqs send-message --queue-url https://sqs.${REGION}.amazonaws.com/053475148537/$LOG_QUEUE_NAME --message-body "$(cat terraform_output.txt)"
      - >
        echo "{\"deployment_id\":\"${DEPLOYMENT_ID}\", \"input_variables\": $INPUT_VARIABLES, \"epoch\": $epoch_milliseconds, \"environment\": \"${ENVIRONMENT}\", \"module\": \"${MODULE_NAME}\"}" > deployment.json
      - cat deployment.json
      - >
        if [ "$EVENT" = "destroy" -a $ret -eq 0 ]; then
          jq '. += {"deleted": 1}' deployment.json > deployment_full.json
        elif [ $ret -eq 0 ]; then
          jq '. += {"deleted": 0}' deployment.json > deployment_full.json
        else
          jq '' deployment.json > deployment_full.json
        fi
      - >
        jq 'with_entries(if .value | type == "string" then .value |= {"S": .} elif .value | type == "number" then .value |= {"N": (tostring)} elif .value | type == "object" then .value |= {"M": (with_entries(if .value | type == "string" then .value |= {"S": .} else . end))} else . end)' deployment_full.json > deployment_dynamodb.json
      - cat deployment_dynamodb.json
      - >
        if [ $ret -eq 0 ]; then
          aws dynamodb put-item --table-name ${DYNAMODB_DEPLOYMENT_TABLE} --item file://deployment_dynamodb.json
        fi
  post_build:
    commands:
      - awk '/Terraform used the /{p=1}p' terraform_output.txt > tf.txt
      - export STATUS="finished"
      - echo ${SIGNAL}
      - tail -10000 tf.txt
      - epoch_seconds=$(date +%s) # Seconds since epoch
      - nanoseconds=$(date +%N) # Nanoseconds since last second
      - grep "Error:" tf.txt > error.txt || touch error.txt
      - ERROR_TEXT="$(cat error.txt)"
      - epoch_milliseconds=$(echo "$epoch_seconds * 1000 + $nanoseconds / 1000000" | bc) # Convert nanoseconds to milliseconds and concatenate
      - >
        echo ${SIGNAL} | jq --arg status "$STATUS" --arg error_text "$ERROR_TEXT" --arg tfContent "$(cat tf.txt)" --arg epoch "$epoch_milliseconds" --arg ts "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" '. + {status: $status, error_text: $error_text, metadata: {terraform: $tfContent}, timestamp: $ts, epoch: ($epoch | tonumber), id: (.deployment_id + "-" + .module + "-" + .name + "-" + .event + "-" + $epoch + "-" + $status)}' > signal_ts_id.json
      - >
        jq 'with_entries(if .value | type == "string" then .value |= {"S": .} elif .value | type == "number" then .value |= {"N": (tostring)} elif .value | type == "object" then .value |= {"M": (with_entries(if .value | type == "string" then .value |= {"S": .} else . end))} else . end)' signal_ts_id.json > signal_dynamodb.json
      - aws dynamodb put-item --table-name ${DYNAMODB_EVENT_TABLE} --item file://signal_dynamodb.json
